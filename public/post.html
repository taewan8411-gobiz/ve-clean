<!doctype html>
<html lang="ko"><meta charset="utf-8" />
<title>문의 상세</title>
<link rel="stylesheet" href="/style.css" />
<body>
<header>
  <div class="container row">
    <h2>문의 상세</h2>
    <nav class="nav right">
      <a href="/index.html">홈</a>
      <a href="/new.html">질문하기</a>
      <a href="/index.html" class="active">답변보기</a>
    </nav>
  </div>
</header>

<div class="container">
  <div class="card"><div id="head" class="muted"></div></div>

  <div class="card">
    <div id="thread" class="bubbles"></div>
    <div id="loading" class="center" style="display:none;margin-top:10px"><div class="spinner"></div></div>
  </div>

  <div class="card">
    <h3>이어 질문하기</h3>
    <textarea id="follow" rows="5" placeholder="추가 질문을 입력하세요"></textarea>
    <div class="row" style="margin-top:10px">
      <button id="send" class="primary">질문 보내기</button>
    </div>
  </div>
</div>

<script>
const params = new URLSearchParams(location.search);
const id = params.get('id');
const headEl = document.getElementById('head');
const threadEl = document.getElementById('thread');
const loadingEl = document.getElementById('loading');

function esc(s){return (s??'').replace(/[&<>"]/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[m]))}
function asText(c){
  if (typeof c === 'string') return c;
  if (Array.isArray(c)) return c.map(p => (typeof p === 'string' ? p : (p?.text ?? JSON.stringify(p)))).join('');
  if (c && typeof c === 'object') return c.text ?? c.content ?? JSON.stringify(c);
  return String(c ?? '');
}
function bold(s){ return s.replace(/\*\*(.+?)\*\*/g,'<strong>$1</strong>'); }
function richHTML(raw){
  const src = (raw||'').replace(/\r\n/g,'\n').replace(/\r/g,'\n');
  const lines = src.split('\n');
  let html='', inUL=false, inOL=false;
  const flush=()=>{ if(inUL){html+='</ul>'; inUL=false;} if(inOL){html+='</ol>'; inOL=false;} };
  for (let t of lines.map(l=>l.trim())){
    if(!t){ flush(); continue; }
    if(/^\d+\.\s+/.test(t)){ if(inUL){html+='</ul>'; inUL=false;} if(!inOL){html+='<ol>'; inOL=true;} html += `<li>${bold(esc(t.replace(/^\d+\.\s+/,'')))}</li>`; continue; }
    if(/^[-*•]\s+/.test(t)){ if(inOL){html+='</ol>'; inOL=false;} if(!inUL){html+='<ul>'; inUL=true;} html += `<li>${bold(esc(t.replace(/^[-*•]\s+/,'')))}</li>`; continue; }
    flush(); html += `<p>${bold(esc(t))}</p>`;
  }
  flush(); return html || '<p>(내용 없음)</p>';
}
function bubble(role, html){
  const div = document.createElement('div');
  div.className = 'bubble' + (role==='user' ? ' user' : '');
  div.innerHTML = (role==='user' ? '<b>[질문]</b> ' : '<b>[AI]</b> ') + html;
  return div;
}

let lastAssistantCount = 0;
let postTitle = '';

async function load(){
  if(!id){ headEl.textContent='잘못된 접근입니다.(id 없음)'; return; }
  const res = await fetch('/api/get-post?id=' + encodeURIComponent(id));
  const data = await res.json();
  if(!res.ok){ headEl.textContent='불러오기 실패: ' + (data?.error || res.status); return; }

  postTitle = data.title || '';
  headEl.innerHTML = `<b>[${esc(data.category||'')}] ${esc(data.title||'')}</b><br>${esc(data.content||'')}`;

  const msgs = Array.isArray(data.messages) ? data.messages : [];
  threadEl.innerHTML = '';
  lastAssistantCount = msgs.filter(m=>m.role==='assistant').length;

  msgs.forEach(m=>{
    let text = asText(m.content);
    // 첫줄이 제목과 거의 동일하면 제거(반복 방지)
    if (m.role==='assistant' && postTitle && text.split('\n')[0]?.trim().replace(/\s+/g,'') === postTitle.trim().replace(/\s+/g,'')){
      text = text.split('\n').slice(1).join('\n');
    }
    threadEl.appendChild(bubble(m.role, richHTML(text)));
  });
}

<script>
  // …(생략: esc/asText/bold/richHTML/bubble/load 동일 유지)…

  async function sendFollow(){
    const ta = document.getElementById('follow');
    const text = ta.value.trim();
    if(!text) return;

    // 버튼 잠그고 사용자 말풍선 + 대기 말풍선
    document.getElementById('send').disabled = true;
    const waiting = bubble('assistant', '<em>AI 답변 생성 중…</em>');
    threadEl.appendChild(bubble('user', richHTML(text)));
    threadEl.appendChild(waiting);
    threadEl.scrollTop = threadEl.scrollHeight;

    try{
      // 서버에 전송 → AI 답변 텍스트를 즉시 돌려줌
      const res = await fetch('/api/reply?id=' + encodeURIComponent(id), {
        method:'POST',
        headers:{ 'Content-Type':'application/json' },
        body: JSON.stringify({ content: text })
      });
      const data = await res.json();

      // 대기 말풍선을 실제 답변으로 교체 (없으면 폴백으로 전체 리로드)
      if (res.ok && data && typeof data.assistant === 'string' && data.assistant.trim()){
        waiting.innerHTML = '<b>[AI]</b> ' + richHTML(data.assistant);
      } else {
        await load();
      }
      ta.value='';
    } finally {
      document.getElementById('send').disabled = false;
      loadingEl.style.display='none';
    }
  }

  document.getElementById('send').addEventListener('click', sendFollow);
</script>

</body>
</html>
