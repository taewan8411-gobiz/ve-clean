<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>문의 상세</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,sans-serif;background:#f6f7fb;margin:0}
    .wrap{max-width:960px;margin:40px auto;padding:0 16px}
    header{display:flex;gap:12px;align-items:center;margin-bottom:16px}
    header a{color:#4b5fd4;text-decoration:none;font-weight:600}
    h1{font-size:22px;margin:0 8px 0 0}
    .card{background:#fff;border-radius:12px;box-shadow:0 2px 10px rgba(16,24,40,.08);padding:16px}
    .muted{color:#8a8fa3}
    #head{margin-bottom:12px;line-height:1.5}
    #thread{display:flex;flex-direction:column;gap:12px;max-height:60vh;overflow:auto;padding:12px;background:#fafbff;border-radius:12px;border:1px solid #e5e7f0}
    .bubble{background:#fff;border:1px solid #e5e7f0;border-radius:12px;padding:12px;line-height:1.6}
    .bubble.user{background:#eff6ff;border-color:#d2e4ff}
    .row{display:flex;gap:8px;margin-top:12px}
    textarea{flex:1;min-height:96px;border:1px solid #e5e7f0;border-radius:10px;padding:10px;resize:vertical}
    button{background:#4b5fd4;color:#fff;border:0;border-radius:10px;padding:10px 14px;cursor:pointer}
    button:disabled{opacity:.6;cursor:not-allowed}
    #loading{display:none;align-items:center;gap:8px;margin:10px 0;color:#8a8fa3}
    .chip{display:inline-block;background:#eef2ff;color:#4751c0;border-radius:999px;padding:2px 10px;font-size:12px;margin-left:6px}
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>문의 상세</h1>
    <a href="/index.html">홈</a>
    <a href="/new.html">질문하기</a>
    <a href="/index.html">답변보기</a>
  </header>

  <div class="card" id="detail">
    <div id="head" class="muted">불러오는 중…</div>
    <div id="thread"></div>

    <div id="loading">⌛ 처리 중…</div>

    <div class="row">
      <textarea id="follow" placeholder="추가 질문을 입력하세요"></textarea>
      <button id="send">질문 보내기</button>
    </div>
  </div>
</div>

<script>
(function(){
  // ========= 공통 유틸 =========
  const qs = new URLSearchParams(location.search);
  const postId = qs.get('id');

  const $head = document.getElementById('head');
  const $thread = document.getElementById('thread');
  const $loading = document.getElementById('loading');
  const $send = document.getElementById('send');
  const $follow = document.getElementById('follow');

  const esc = s => (s??'').toString().replace(/[&<>"]/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[m]));
  const asText = c => {
    if (typeof c === 'string') return c;
    if (Array.isArray(c)) return c.map(p => (typeof p === 'string' ? p : (p?.text ?? JSON.stringify(p)))).join('');
    if (c && typeof c === 'object') return c.text ?? c.content ?? JSON.stringify(c);
    return String(c ?? '');
  };
  const bold = s => s.replace(/\*\*(.+?)\*\*/g,'<strong>$1</strong>');
  const richHTML = raw => {
    const src = (raw||'').replace(/\r\n/g,'\n').replace(/\r/g,'\n');
    const lines = src.split('\n');
    let html='', inUL=false, inOL=false;
    const flush=()=>{ if(inUL){html+='</ul>'; inUL=false;} if(inOL){html+='</ol>'; inOL=false;} };
    for (let t of lines.map(l=>l.trim())){
      if(!t){ flush(); continue; }
      if(/^\d+\.\s+/.test(t)){ if(inUL){html+='</ul>'; inUL=false;} if(!inOL){html+='<ol>'; inOL=true;} html += `<li>${bold(esc(t.replace(/^\d+\.\s+/,'')))}</li>`; continue; }
      if(/^[-*•]\s+/.test(t)){ if(inOL){html+='</ol>'; inOL=false;} if(!inUL){html+='<ul>'; inUL=true;} html += `<li>${bold(esc(t.replace(/^[-*•]\s+/,'')))}</li>`; continue; }
      flush(); html += `<p>${bold(esc(t))}</p>`;
    }
    flush(); return html || '<p>(내용 없음)</p>';
  };
  const bubble = (role,html) => {
    const d = document.createElement('div');
    d.className = 'bubble' + (role==='user'?' user':'');
    d.innerHTML = (role==='user' ? '<b>[질문]</b> ' : '<b>[AI]</b> ') + html;
    return d;
  };

  let prevAssistantCount = 0;
  let postTitle = '';

  // ========= API =========
  async function apiGetPost(){
    const r = await fetch('/api/get-post?id=' + encodeURIComponent(postId));
    const j = await r.json().catch(()=> ({}));
    if (!r.ok) throw new Error(j?.error || r.statusText);
    return j;
  }
  async function apiReply(text){
    const r = await fetch('/api/reply?id=' + encodeURIComponent(postId), {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ content: text })
    });
    return r.json().catch(()=> ({}));
  }

  // ========= 렌더 =========
  function renderHead(data){
    const when = new Date(Number(data.createdAt)||Date.now());
    const time = `${when.getFullYear()}.${String(when.getMonth()+1).padStart(2,'0')}.${String(when.getDate()).padStart(2,'0')} ${String(when.getHours()).padStart(2,'0')}:${String(when.getMinutes()).padStart(2,'0')}`;
    $head.innerHTML = `<b>[${esc(data.category||'')}] ${esc(data.title||'')}</b>
      <span class="chip">${time}</span><br>${esc(data.content||'')}`;
  }
  function renderThread(messages){
    $thread.innerHTML = '';
    if (!messages || !messages.length){
      $thread.innerHTML = '<div class="muted">아직 메시지가 없습니다.</div>';
      prevAssistantCount = 0;
      return;
    }
    prevAssistantCount = messages.filter(m => m.role==='assistant').length;
    messages.forEach(m=>{
      let t = asText(m.content);
      // 첫 답변이 제목을 그대로 반복하는 경우 제거
      if (m.role==='assistant' && postTitle && t.split('\n')[0]?.trim().replace(/\s+/g,'') === postTitle.trim().replace(/\s+/g,'')){
        t = t.split('\n').slice(1).join('\n');
      }
      $thread.appendChild(bubble(m.role, richHTML(t)));
    });
    $thread.scrollTop = $thread.scrollHeight;
  }

  // ========= 동작 =========
  async function load(){
    if (!postId){
      $head.innerHTML = '<span class="muted">잘못된 접근입니다. (?id=글번호 필요)</span>';
      return;
    }
    $loading.style.display='flex';
    try {
      const data = await apiGetPost();
      postTitle = data.title || '';
      renderHead(data);
      renderThread(data.messages || []);
    } catch (e) {
      $head.innerHTML = `<span class="muted">불러오기 실패: ${esc(String(e.message||e))}</span>`;
      $thread.innerHTML = '';
    } finally {
      $loading.style.display='none';
    }
  }

  async function pollUntilAssistant(timeout=60000, step=1500, waitingEl){
    const end = Date.now() + timeout;
    while (Date.now() < end){
      try{
        const data = await apiGetPost();
        const now = (data.messages||[]).filter(m=>m.role==='assistant').length;
        if (now > prevAssistantCount){
          renderHead(data);
          renderThread(data.messages||[]);
          if (waitingEl) waitingEl.remove();
          return true;
        }
      }catch{}
      await new Promise(r => setTimeout(r, step));
    }
    return false;
  }

  async function onSend(){
    const text = ($follow.value||'').trim();
    if (!text) return;

    $send.disabled = true;

    // 사용자 + 대기 말풍선
    const me = bubble('user', richHTML(text));
    const wait = bubble('assistant','<em>AI 답변 생성 중…</em>');
    $thread.appendChild(me); $thread.appendChild(wait);
    $thread.scrollTop = $thread.scrollHeight;

    try{
      const res = await apiReply(text);

      // 1) 응답 본문에 바로 답변이 있으면 즉시 반영
      if (res && typeof res.assistant === 'string' && res.assistant.trim()){
        wait.innerHTML = '<b>[AI]</b> ' + richHTML(res.assistant);
        prevAssistantCount += 1; // 추정 반영
      } else {
        // 2) 저장 반영될 때까지 폴링(보장)
        const ok = await pollUntilAssistant(60000, 1500, wait);
        if (!ok) {
          wait.innerHTML = '<em>답변 생성이 지연되고 있습니다. 잠시 후 자동 갱신되거나 새로고침 해 주세요.</em>';
        }
      }
      $follow.value='';
    } finally {
      $send.disabled = false;
      $loading.style.display='none';
    }
  }

  // ========= bootstrap =========
  $send.addEventListener('click', onSend);
  load();
})();
</script>
</body>
</html>
