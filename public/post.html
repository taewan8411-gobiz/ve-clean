<script>
  // 상단 메뉴 활성
  (function(){ const el=document.querySelector('.nav a[data-nav="answers"]'); if(el) el.classList.add('active'); })();

  const params = new URLSearchParams(location.search);
  const id = params.get('id');

  const headEl   = document.getElementById('head');
  const threadEl = document.getElementById('thread');
  const loadingEl= document.getElementById('loading');

  // ── 유틸
  function esc(s){return (s??'').replace(/[&<>"]/g,m=>({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"}[m]))}
  function asText(c){
    if (typeof c === 'string') return c;
    if (Array.isArray(c)) return c.map(p => (typeof p === 'string' ? p : (p?.text ?? JSON.stringify(p)))).join('');
    if (c && typeof c === 'object') return c.text ?? c.content ?? JSON.stringify(c);
    return String(c ?? '');
  }
  // **굵게, 목록, 단락 변환 (아주 가벼운 마크다운 렌더러)**
  function richHTML(raw){
    const src = (raw||'').replace(/\r\n/g,'\n').replace(/\r/g,'\n');
    const lines = src.split('\n');
    let html='', inUL=false, inOL=false;
    const flush = () => { if(inUL){html+='</ul>'; inUL=false;} if(inOL){html+='</ol>'; inOL=false;} };

    for (let line of lines){
      const t=line.trim();
      if (!t){
        flush();
        continue;
      }
      // ordered list: 1. 2. ...
      if (/^\d+\.\s+/.test(t)){
        if(inUL){html+='</ul>'; inUL=false;}
        if(!inOL){html+='<ol>'; inOL=true;}
        const item = t.replace(/^\d+\.\s+/,'');
        html += `<li>${bold(esc(item))}</li>`;
        continue;
      }
      // unordered list: -, *, •
      if (/^[-*•]\s+/.test(t)){
        if(inOL){html+='</ol>'; inOL=false;}
        if(!inUL){html+='<ul>'; inUL=true;}
        const item = t.replace(/^[-*•]\s+/,'');
        html += `<li>${bold(esc(item))}</li>`;
        continue;
      }
      // 일반 문단
      flush();
      html += `<p>${bold(esc(t))}</p>`;
    }
    flush();
    return html || '<p>(내용 없음)</p>';
  }
  function bold(s){ return s.replace(/\*\*(.+?)\*\*/g,'<strong>$1</strong>'); }

  function bubble(role, html){
const div = document.createElement('div');
div.innerHTML = `[AI] ${message.content
  .replace(/\n/g, '<br>')
  .replace(/\*\*(.*?)\*\*/g, '<b>$1</b>')}`;
document.getElementById('reply-container').appendChild(div);

  // 최근 assistant 개수를 추적해 폴링에 사용
  let lastAssistantCount = 0;
  let postTitle = '';

  async function load(){
    if(!id){ headEl.textContent='잘못된 접근입니다.(id 없음)'; return; }
    const res = await fetch('/api/get-post?id=' + encodeURIComponent(id));
    const data = await res.json();
    if(!res.ok){ headEl.textContent='불러오기 실패: ' + (data?.error||res.status); return; }

    postTitle = data.title || '';
    headEl.innerHTML = `<b>[${esc(data.category||'')}] ${esc(data.title||'')}</b><br>${esc(data.content||'')}`;

    const msgs = Array.isArray(data.messages) ? data.messages : [];
    threadEl.innerHTML = '';

    // assistant 개수 집계 (폴링용)
    lastAssistantCount = msgs.filter(m => m.role==='assistant').length;

    // 렌더링 (AI가 질문을 그대로 되뇌는 첫 줄은 제거 시도)
    msgs.forEach(m=>{
      let text = asText(m.content);
      // 질문/제목 반복이 보이면 첫 줄 제거
      if (m.role==='assistant' && postTitle && text.split('\n')[0]?.trim().replace(/\s+/g,'') === postTitle.trim().replace(/\s+/g,'')){
        text = text.split('\n').slice(1).join('\n');
      }
      threadEl.appendChild(bubble(m.role, richHTML(text)));
    });
  }

  // 이어 질문하기
  async function sendFollow(){
    const ta = document.getElementById('follow');
    const text = ta.value.trim();
    if(!text) return;
    document.getElementById('send').disabled = true;
    // 사용자 말풍선 즉시 추가
    threadEl.appendChild(bubble('user', richHTML(text)));
    // AI 대기 말풍선
    const waiting = bubble('assistant','<em>AI 답변 생성 중…</em>');
    threadEl.appendChild(waiting);
    threadEl.scrollTop = threadEl.scrollHeight;

    try{
      await fetch('/api/reply?id=' + encodeURIComponent(id), {
        method:'POST',
        headers:{ 'Content-Type':'application/json' },
        body: JSON.stringify({ content:text })
      });
      ta.value='';

      // 새 assistant가 나타날 때까지 짧게 폴링 (최대 30초)
      const until = Date.now()+30000;
      while(Date.now()<until){
        await new Promise(r=>setTimeout(r,1200));
        const res = await fetch('/api/get-post?id=' + encodeURIComponent(id));
        const data = await res.json();
        const cnt = (data.messages||[]).filter(m=>m.role==='assistant').length;
        if(cnt>lastAssistantCount){
          await load(); // 전체 다시 그림
          break;
        }
      }
    } finally{
      document.getElementById('send').disabled = false;
      loadingEl.style.display = 'none';
    }
  }

  document.getElementById('send').addEventListener('click', sendFollow);
  load();
</script>
