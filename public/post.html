<script>
  const params = new URLSearchParams(location.search);
  const id = params.get('id');

  const headEl = document.getElementById('head');
  const threadEl = document.getElementById('thread');
  const loadingEl = document.getElementById('loading');

  function esc(s){return (s??'').replace(/[&<>"]/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[m]))}
  function asText(c){
    if (typeof c === 'string') return c;
    if (Array.isArray(c)) return c.map(p => (typeof p === 'string' ? p : (p?.text ?? JSON.stringify(p)))).join('');
    if (c && typeof c === 'object') return c.text ?? c.content ?? JSON.stringify(c);
    return String(c ?? '');
  }
  function bold(s){ return s.replace(/\*\*(.+?)\*\*/g,'<strong>$1</strong>'); }
  function richHTML(raw){
    const src = (raw||'').replace(/\r\n/g,'\n').replace(/\r/g,'\n');
    const lines = src.split('\n');
    let html='', inUL=false, inOL=false;
    const flush=()=>{ if(inUL){html+='</ul>'; inUL=false;} if(inOL){html+='</ol>'; inOL=false;} };
    for (let t of lines.map(l=>l.trim())){
      if(!t){ flush(); continue; }
      if(/^\d+\.\s+/.test(t)){ if(inUL){html+='</ul>'; inUL=false;} if(!inOL){html+='<ol>'; inOL=true;} html += `<li>${bold(esc(t.replace(/^\d+\.\s+/,'')))}</li>`; continue; }
      if(/^[-*•]\s+/.test(t)){ if(inOL){html+='</ol>'; inOL=false;} if(!inUL){html+='<ul>'; inUL=true;} html += `<li>${bold(esc(t.replace(/^[-*•]\s+/,'')))}</li>`; continue; }
      flush(); html += `<p>${bold(esc(t))}</p>`;
    }
    flush(); return html || '<p>(내용 없음)</p>';
  }
  function bubble(role, html){
    const div = document.createElement('div');
    div.className = 'bubble' + (role==='user' ? ' user' : '');
    div.innerHTML = (role==='user' ? '<b>[질문]</b> ' : '<b>[AI]</b> ') + html;
    return div;
  }

  // 직전까지 저장된 assistant 개수(폴링 비교용)
  let prevAssistantCount = 0;
  let postTitle = '';

  async function fetchPost(){
    const res = await fetch('/api/get-post?id=' + encodeURIComponent(id));
    const data = await res.json();
    if (!res.ok) throw new Error(data?.error || res.statusText);
    return data;
  }

  function renderThread(messages){
    threadEl.innerHTML = '';
    if (!messages || !messages.length){
      threadEl.innerHTML = '<div class="muted">아직 메시지가 없습니다.</div>';
      return;
    }
    prevAssistantCount = messages.filter(m => m.role==='assistant').length;
    messages.forEach(m=>{
      let text = asText(m.content);
      // 첫 답변에서 제목 재반복 제거
      if (m.role==='assistant' && postTitle && text.split('\n')[0]?.trim().replace(/\s+/g,'') === postTitle.trim().replace(/\s+/g,'')){
        text = text.split('\n').slice(1).join('\n');
      }
      threadEl.appendChild(bubble(m.role, richHTML(text)));
    });
    threadEl.scrollTop = threadEl.scrollHeight;
  }

  async function load(){
    if(!id){ headEl.textContent='잘못된 접근입니다.(id 없음)'; return; }
    loadingEl.style.display='flex';
    try {
      const data = await fetchPost();
      postTitle = data.title || '';
      headEl.innerHTML = `<b>[${esc(data.category||'')}] ${esc(data.title||'')}</b><br>${esc(data.content||'')}`;
      renderThread(data.messages);
    } catch (e) {
      headEl.innerHTML = `<span class="muted">불러오기 실패: ${esc(String(e.message||e))}</span>`;
      threadEl.innerHTML = '';
    } finally {
      loadingEl.style.display='none';
    }
  }

  // ❗️reply 요청 후, 서버에 assistant가 새로 저장될 때까지 폴링 (최대 60초)
  async function pollUntilNewAssistant(timeoutMs = 60000, intervalMs = 1500, waitingEl){
    const end = Date.now() + timeoutMs;
    while (Date.now() < end) {
      try {
        const data = await fetchPost();
        const count = (data.messages||[]).filter(m=>m.role==='assistant').length;
        if (count > prevAssistantCount) {
          renderThread(data.messages);
          if (waitingEl) waitingEl.remove();
          return true;
        }
      } catch { /* 무시하고 재시도 */ }
      await new Promise(r => setTimeout(r, intervalMs));
    }
    return false;
  }

  async function sendFollow(){
    const ta = document.getElementById('follow');
    const text = ta.value.trim();
    if(!text) return;

    document.getElementById('send').disabled = true;

    // 사용자 말풍선 + 대기 말풍선
    const userNode = bubble('user', richHTML(text));
    const waiting = bubble('assistant', '<em>AI 답변 생성 중…</em>');
    threadEl.appendChild(userNode);
    threadEl.appendChild(waiting);
    threadEl.scrollTop = threadEl.scrollHeight;

    try{
      // 서버에 전송 (응답 본문은 참고용, 최종 반영은 폴링으로 보장)
      const res = await fetch('/api/reply?id=' + encodeURIComponent(id), {
        method:'POST',
        headers:{ 'Content-Type':'application/json' },
        body: JSON.stringify({ content: text })
      });
      const data = await res.json().catch(()=> ({}));

      // 1) 응답에 assistant가 있으면 즉시 반영
      if (res.ok && data && typeof data.assistant === 'string' && data.assistant.trim()){
        waiting.innerHTML = '<b>[AI]</b> ' + richHTML(data.assistant);
        // prevAssistantCount 증가 추정(저장도 되었을 가능성), 혹시 몰라 다음 폴링으로 동기화
        prevAssistantCount += 1;
      } else {
        // 2) 폴링으로 반드시 화면 반영 보장
        const ok = await pollUntilNewAssistant(60000, 1500, waiting);
        if (!ok) {
          // 폴링 타임아웃 → 안내 메시지
          waiting.innerHTML = '<em>답변 생성에 시간이 걸리고 있습니다. 잠시 후 자동 새로고침되거나, 페이지를 새로고침해 주세요.</em>';
        }
      }
      ta.value='';
    } finally {
      document.getElementById('send').disabled = false;
      loadingEl.style.display='none';
    }
  }

  document.getElementById('send').addEventListener('click', sendFollow);
  load();
</script>
